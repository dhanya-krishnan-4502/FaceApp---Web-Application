{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { createCanvas, createCanvasFromMedia, env, getContext2dOrThrow } from 'tfjs-image-recognition-base';\nimport { normalize } from './normalize';\nexport function extractImagePatches(img, boxes, _a) {\n  var width = _a.width,\n    height = _a.height;\n  return tslib_1.__awaiter(this, void 0, void 0, function () {\n    var imgCtx, bitmaps, imagePatchesDatas;\n    var _this = this;\n    return tslib_1.__generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          imgCtx = getContext2dOrThrow(img);\n          return [4 /*yield*/, Promise.all(boxes.map(function (box) {\n            return tslib_1.__awaiter(_this, void 0, void 0, function () {\n              var _a, y, ey, x, ex, fromX, fromY, imgData;\n              return tslib_1.__generator(this, function (_b) {\n                _a = box.padAtBorders(img.height, img.width), y = _a.y, ey = _a.ey, x = _a.x, ex = _a.ex;\n                fromX = x - 1;\n                fromY = y - 1;\n                imgData = imgCtx.getImageData(fromX, fromY, ex - fromX, ey - fromY);\n                return [2 /*return*/, env.isNodejs() ? createCanvasFromMedia(imgData) : createImageBitmap(imgData)];\n              });\n            });\n          }))];\n        case 1:\n          bitmaps = _b.sent();\n          imagePatchesDatas = [];\n          bitmaps.forEach(function (bmp) {\n            var patch = createCanvas({\n              width: width,\n              height: height\n            });\n            var patchCtx = getContext2dOrThrow(patch);\n            patchCtx.drawImage(bmp, 0, 0, width, height);\n            var data = patchCtx.getImageData(0, 0, width, height).data;\n            var currData = [];\n            // RGBA -> BGR\n            for (var i = 0; i < data.length; i += 4) {\n              currData.push(data[i + 2]);\n              currData.push(data[i + 1]);\n              currData.push(data[i]);\n            }\n            imagePatchesDatas.push(currData);\n          });\n          return [2 /*return*/, imagePatchesDatas.map(function (data) {\n            var t = tf.tidy(function () {\n              var imagePatchTensor = tf.transpose(tf.tensor4d(data, [1, width, height, 3]), [0, 2, 1, 3]).toFloat();\n              return normalize(imagePatchTensor);\n            });\n            return t;\n          })];\n      }\n    });\n  });\n}","map":{"version":3,"names":["tf","createCanvas","createCanvasFromMedia","env","getContext2dOrThrow","normalize","extractImagePatches","img","boxes","_a","width","height","imgCtx","Promise","all","map","box","tslib_1","__awaiter","_this","padAtBorders","y","ey","x","ex","fromX","fromY","imgData","getImageData","isNodejs","createImageBitmap","bitmaps","_b","sent","imagePatchesDatas","forEach","bmp","patch","patchCtx","drawImage","data","currData","i","length","push","t","tidy","imagePatchTensor","transpose","tensor4d","toFloat"],"sources":["/Users/dhanya/node_modules/face-api.js/src/mtcnn/extractImagePatches.ts"],"sourcesContent":["import * as tf from '@tensorflow/tfjs-core';\r\nimport {\r\n  Box,\r\n  createCanvas,\r\n  createCanvasFromMedia,\r\n  env,\r\n  getContext2dOrThrow,\r\n  IDimensions,\r\n} from 'tfjs-image-recognition-base';\r\n\r\nimport { normalize } from './normalize';\r\n\r\nexport async function extractImagePatches(\r\n  img: HTMLCanvasElement,\r\n  boxes: Box[],\r\n  { width, height }: IDimensions\r\n): Promise<tf.Tensor4D[]> {\r\n\r\n\r\n  const imgCtx = getContext2dOrThrow(img)\r\n\r\n  const bitmaps = await Promise.all(boxes.map(async box => {\r\n    // TODO: correct padding\r\n    const { y, ey, x, ex } = box.padAtBorders(img.height, img.width)\r\n\r\n    const fromX = x - 1\r\n    const fromY = y - 1\r\n    const imgData = imgCtx.getImageData(fromX, fromY, (ex - fromX), (ey - fromY))\r\n\r\n    return env.isNodejs() ? createCanvasFromMedia(imgData) : createImageBitmap(imgData)\r\n  }))\r\n\r\n  const imagePatchesDatas: number[][] = []\r\n\r\n  bitmaps.forEach(bmp => {\r\n    const patch = createCanvas({ width, height })\r\n    const patchCtx = getContext2dOrThrow(patch)\r\n    patchCtx.drawImage(bmp, 0, 0, width, height)\r\n    const { data } = patchCtx.getImageData(0, 0, width, height)\r\n\r\n    const currData = []\r\n    // RGBA -> BGR\r\n    for(let i = 0; i < data.length; i+=4) {\r\n      currData.push(data[i + 2])\r\n      currData.push(data[i + 1])\r\n      currData.push(data[i])\r\n    }\r\n    imagePatchesDatas.push(currData)\r\n  })\r\n\r\n\r\n  return imagePatchesDatas.map(data => {\r\n    const t = tf.tidy(() => {\r\n      const imagePatchTensor = tf.transpose(\r\n        tf.tensor4d(data, [1, width, height, 3]),\r\n        [0, 2, 1, 3]\r\n      ).toFloat() as tf.Tensor4D\r\n\r\n      return normalize(imagePatchTensor)\r\n    })\r\n    return t\r\n  })\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}