{"ast":null,"code":"import * as tslib_1 from \"tslib\";\nimport * as tf from '@tensorflow/tfjs-core';\nimport { BoundingBox } from '../classes/BoundingBox';\nimport { ObjectDetection } from '../classes/ObjectDetection';\nimport { convLayer } from '../common';\nimport { toNetInput } from '../dom';\nimport { NeuralNetwork } from '../NeuralNetwork';\nimport { sigmoid } from '../ops';\nimport { nonMaxSuppression } from '../ops/nonMaxSuppression';\nimport { normalize } from '../ops/normalize';\nimport { validateConfig } from './config';\nimport { convWithBatchNorm } from './convWithBatchNorm';\nimport { depthwiseSeparableConv } from './depthwiseSeparableConv';\nimport { extractParams } from './extractParams';\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\nimport { leaky } from './leaky';\nimport { TinyYolov2Options } from './TinyYolov2Options';\nvar TinyYolov2 = /** @class */function (_super) {\n  tslib_1.__extends(TinyYolov2, _super);\n  function TinyYolov2(config) {\n    var _this = _super.call(this, 'TinyYolov2') || this;\n    validateConfig(config);\n    _this._config = config;\n    return _this;\n  }\n  Object.defineProperty(TinyYolov2.prototype, \"config\", {\n    get: function () {\n      return this._config;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2.prototype, \"withClassScores\", {\n    get: function () {\n      return this.config.withClassScores || this.config.classes.length > 1;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(TinyYolov2.prototype, \"boxEncodingSize\", {\n    get: function () {\n      return 5 + (this.withClassScores ? this.config.classes.length : 0);\n    },\n    enumerable: true,\n    configurable: true\n  });\n  TinyYolov2.prototype.runTinyYolov2 = function (x, params) {\n    var out = convWithBatchNorm(x, params.conv0);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv1);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv2);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv3);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv4);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = convWithBatchNorm(out, params.conv5);\n    out = tf.maxPool(out, [2, 2], [1, 1], 'same');\n    out = convWithBatchNorm(out, params.conv6);\n    out = convWithBatchNorm(out, params.conv7);\n    return convLayer(out, params.conv8, 'valid', false);\n  };\n  TinyYolov2.prototype.runMobilenet = function (x, params) {\n    var out = this.config.isFirstLayerConv2d ? leaky(convLayer(x, params.conv0, 'valid', false)) : depthwiseSeparableConv(x, params.conv0);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv1);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv2);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv3);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv4);\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same');\n    out = depthwiseSeparableConv(out, params.conv5);\n    out = tf.maxPool(out, [2, 2], [1, 1], 'same');\n    out = params.conv6 ? depthwiseSeparableConv(out, params.conv6) : out;\n    out = params.conv7 ? depthwiseSeparableConv(out, params.conv7) : out;\n    return convLayer(out, params.conv8, 'valid', false);\n  };\n  TinyYolov2.prototype.forwardInput = function (input, inputSize) {\n    var _this = this;\n    var params = this.params;\n    if (!params) {\n      throw new Error('TinyYolov2 - load model before inference');\n    }\n    return tf.tidy(function () {\n      var batchTensor = input.toBatchTensor(inputSize, false).toFloat();\n      batchTensor = _this.config.meanRgb ? normalize(batchTensor, _this.config.meanRgb) : batchTensor;\n      batchTensor = batchTensor.div(tf.scalar(256));\n      return _this.config.withSeparableConvs ? _this.runMobilenet(batchTensor, params) : _this.runTinyYolov2(batchTensor, params);\n    });\n  };\n  TinyYolov2.prototype.forward = function (input, inputSize) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var _a;\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = this.forwardInput;\n            return [4 /*yield*/, toNetInput(input)];\n          case 1:\n            return [4 /*yield*/, _a.apply(this, [_b.sent(), inputSize])];\n          case 2:\n            return [2 /*return*/, _b.sent()];\n        }\n      });\n    });\n  };\n  TinyYolov2.prototype.detect = function (input, forwardParams) {\n    if (forwardParams === void 0) {\n      forwardParams = {};\n    }\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var _a, inputSize, scoreThreshold, netInput, out, out0, inputDimensions, results, boxes, scores, classScores, classNames, indices, detections;\n      var _this = this;\n      return tslib_1.__generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            _a = new TinyYolov2Options(forwardParams), inputSize = _a.inputSize, scoreThreshold = _a.scoreThreshold;\n            return [4 /*yield*/, toNetInput(input)];\n          case 1:\n            netInput = _b.sent();\n            return [4 /*yield*/, this.forwardInput(netInput, inputSize)];\n          case 2:\n            out = _b.sent();\n            out0 = tf.tidy(function () {\n              return tf.unstack(out)[0].expandDims();\n            });\n            inputDimensions = {\n              width: netInput.getInputWidth(0),\n              height: netInput.getInputHeight(0)\n            };\n            return [4 /*yield*/, this.extractBoxes(out0, netInput.getReshapedInputDimensions(0), scoreThreshold)];\n          case 3:\n            results = _b.sent();\n            out.dispose();\n            out0.dispose();\n            boxes = results.map(function (res) {\n              return res.box;\n            });\n            scores = results.map(function (res) {\n              return res.score;\n            });\n            classScores = results.map(function (res) {\n              return res.classScore;\n            });\n            classNames = results.map(function (res) {\n              return _this.config.classes[res.label];\n            });\n            indices = nonMaxSuppression(boxes.map(function (box) {\n              return box.rescale(inputSize);\n            }), scores, this.config.iouThreshold, true);\n            detections = indices.map(function (idx) {\n              return new ObjectDetection(scores[idx], classScores[idx], classNames[idx], boxes[idx], inputDimensions);\n            });\n            return [2 /*return*/, detections];\n        }\n      });\n    });\n  };\n  TinyYolov2.prototype.getDefaultModelName = function () {\n    return '';\n  };\n  TinyYolov2.prototype.extractParamsFromWeigthMap = function (weightMap) {\n    return extractParamsFromWeigthMap(weightMap, this.config);\n  };\n  TinyYolov2.prototype.extractParams = function (weights) {\n    var filterSizes = this.config.filterSizes || TinyYolov2.DEFAULT_FILTER_SIZES;\n    var numFilters = filterSizes ? filterSizes.length : undefined;\n    if (numFilters !== 7 && numFilters !== 8 && numFilters !== 9) {\n      throw new Error(\"TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found \" + numFilters + \" filterSizes in config\");\n    }\n    return extractParams(weights, this.config, this.boxEncodingSize, filterSizes);\n  };\n  TinyYolov2.prototype.extractBoxes = function (outputTensor, inputBlobDimensions, scoreThreshold) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var width, height, inputSize, correctionFactorX, correctionFactorY, numCells, numBoxes, _a, boxesTensor, scoresTensor, classScoresTensor, results, scoresData, boxesData, row, col, anchor, score, ctX, ctY, width_1, height_1, x, y, pos, _b, classScore, label, _c;\n      var _this = this;\n      return tslib_1.__generator(this, function (_d) {\n        switch (_d.label) {\n          case 0:\n            width = inputBlobDimensions.width, height = inputBlobDimensions.height;\n            inputSize = Math.max(width, height);\n            correctionFactorX = inputSize / width;\n            correctionFactorY = inputSize / height;\n            numCells = outputTensor.shape[1];\n            numBoxes = this.config.anchors.length;\n            _a = tf.tidy(function () {\n              var reshaped = outputTensor.reshape([numCells, numCells, numBoxes, _this.boxEncodingSize]);\n              var boxes = reshaped.slice([0, 0, 0, 0], [numCells, numCells, numBoxes, 4]);\n              var scores = reshaped.slice([0, 0, 0, 4], [numCells, numCells, numBoxes, 1]);\n              var classScores = _this.withClassScores ? tf.softmax(reshaped.slice([0, 0, 0, 5], [numCells, numCells, numBoxes, _this.config.classes.length]), 3) : tf.scalar(0);\n              return [boxes, scores, classScores];\n            }), boxesTensor = _a[0], scoresTensor = _a[1], classScoresTensor = _a[2];\n            results = [];\n            return [4 /*yield*/, scoresTensor.array()];\n          case 1:\n            scoresData = _d.sent();\n            return [4 /*yield*/, boxesTensor.array()];\n          case 2:\n            boxesData = _d.sent();\n            row = 0;\n            _d.label = 3;\n          case 3:\n            if (!(row < numCells)) return [3 /*break*/, 12];\n            col = 0;\n            _d.label = 4;\n          case 4:\n            if (!(col < numCells)) return [3 /*break*/, 11];\n            anchor = 0;\n            _d.label = 5;\n          case 5:\n            if (!(anchor < numBoxes)) return [3 /*break*/, 10];\n            score = sigmoid(scoresData[row][col][anchor][0]);\n            if (!(!scoreThreshold || score > scoreThreshold)) return [3 /*break*/, 9];\n            ctX = (col + sigmoid(boxesData[row][col][anchor][0])) / numCells * correctionFactorX;\n            ctY = (row + sigmoid(boxesData[row][col][anchor][1])) / numCells * correctionFactorY;\n            width_1 = Math.exp(boxesData[row][col][anchor][2]) * this.config.anchors[anchor].x / numCells * correctionFactorX;\n            height_1 = Math.exp(boxesData[row][col][anchor][3]) * this.config.anchors[anchor].y / numCells * correctionFactorY;\n            x = ctX - width_1 / 2;\n            y = ctY - height_1 / 2;\n            pos = {\n              row: row,\n              col: col,\n              anchor: anchor\n            };\n            if (!this.withClassScores) return [3 /*break*/, 7];\n            return [4 /*yield*/, this.extractPredictedClass(classScoresTensor, pos)];\n          case 6:\n            _c = _d.sent();\n            return [3 /*break*/, 8];\n          case 7:\n            _c = {\n              classScore: 1,\n              label: 0\n            };\n            _d.label = 8;\n          case 8:\n            _b = _c, classScore = _b.classScore, label = _b.label;\n            results.push(tslib_1.__assign({\n              box: new BoundingBox(x, y, x + width_1, y + height_1),\n              score: score,\n              classScore: score * classScore,\n              label: label\n            }, pos));\n            _d.label = 9;\n          case 9:\n            anchor++;\n            return [3 /*break*/, 5];\n          case 10:\n            col++;\n            return [3 /*break*/, 4];\n          case 11:\n            row++;\n            return [3 /*break*/, 3];\n          case 12:\n            boxesTensor.dispose();\n            scoresTensor.dispose();\n            classScoresTensor.dispose();\n            return [2 /*return*/, results];\n        }\n      });\n    });\n  };\n  TinyYolov2.prototype.extractPredictedClass = function (classesTensor, pos) {\n    return tslib_1.__awaiter(this, void 0, void 0, function () {\n      var row, col, anchor, classesData;\n      return tslib_1.__generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            row = pos.row, col = pos.col, anchor = pos.anchor;\n            return [4 /*yield*/, classesTensor.array()];\n          case 1:\n            classesData = _a.sent();\n            return [2 /*return*/, Array(this.config.classes.length).fill(0).map(function (_, i) {\n              return classesData[row][col][anchor][i];\n            }).map(function (classScore, label) {\n              return {\n                classScore: classScore,\n                label: label\n              };\n            }).reduce(function (max, curr) {\n              return max.classScore > curr.classScore ? max : curr;\n            })];\n        }\n      });\n    });\n  };\n  TinyYolov2.DEFAULT_FILTER_SIZES = [3, 16, 32, 64, 128, 256, 512, 1024, 1024];\n  return TinyYolov2;\n}(NeuralNetwork);\nexport { TinyYolov2 };","map":{"version":3,"names":["tf","BoundingBox","ObjectDetection","convLayer","toNetInput","NeuralNetwork","sigmoid","nonMaxSuppression","normalize","validateConfig","convWithBatchNorm","depthwiseSeparableConv","extractParams","extractParamsFromWeigthMap","leaky","TinyYolov2Options","TinyYolov2","_super","tslib_1","__extends","config","_this","call","_config","Object","defineProperty","prototype","get","withClassScores","classes","length","runTinyYolov2","x","params","out","conv0","maxPool","conv1","conv2","conv3","conv4","conv5","conv6","conv7","conv8","runMobilenet","isFirstLayerConv2d","forwardInput","input","inputSize","Error","tidy","batchTensor","toBatchTensor","toFloat","meanRgb","div","scalar","withSeparableConvs","forward","_a","apply","_b","sent","detect","forwardParams","scoreThreshold","netInput","out0","unstack","expandDims","inputDimensions","width","getInputWidth","height","getInputHeight","extractBoxes","getReshapedInputDimensions","results","dispose","boxes","map","res","box","scores","score","classScores","classScore","classNames","label","indices","rescale","iouThreshold","detections","idx","getDefaultModelName","weightMap","weights","filterSizes","DEFAULT_FILTER_SIZES","numFilters","undefined","boxEncodingSize","outputTensor","inputBlobDimensions","Math","max","correctionFactorX","correctionFactorY","numCells","shape","numBoxes","anchors","reshaped","reshape","slice","softmax","boxesTensor","scoresTensor","classScoresTensor","array","scoresData","_d","boxesData","row","col","anchor","ctX","ctY","width_1","exp","height_1","y","pos","extractPredictedClass","_c","push","__assign","classesTensor","classesData","Array","fill","_","i","reduce","curr"],"sources":["/Users/dhanya/node_modules/tfjs-image-recognition-base/src/tinyYolov2/TinyYolov2.ts"],"sourcesContent":["import * as tf from '@tensorflow/tfjs-core';\r\n\r\nimport { BoundingBox } from '../classes/BoundingBox';\r\nimport { Dimensions } from '../classes/Dimensions';\r\nimport { ObjectDetection } from '../classes/ObjectDetection';\r\nimport { convLayer } from '../common';\r\nimport { ConvParams, SeparableConvParams } from '../common/types';\r\nimport { toNetInput } from '../dom';\r\nimport { NetInput } from '../dom/NetInput';\r\nimport { TNetInput } from '../dom/types';\r\nimport { NeuralNetwork } from '../NeuralNetwork';\r\nimport { sigmoid } from '../ops';\r\nimport { nonMaxSuppression } from '../ops/nonMaxSuppression';\r\nimport { normalize } from '../ops/normalize';\r\nimport { TinyYolov2Config, validateConfig } from './config';\r\nimport { convWithBatchNorm } from './convWithBatchNorm';\r\nimport { depthwiseSeparableConv } from './depthwiseSeparableConv';\r\nimport { extractParams } from './extractParams';\r\nimport { extractParamsFromWeigthMap } from './extractParamsFromWeigthMap';\r\nimport { leaky } from './leaky';\r\nimport { ITinyYolov2Options, TinyYolov2Options } from './TinyYolov2Options';\r\nimport { DefaultTinyYolov2NetParams, MobilenetParams, TinyYolov2NetParams } from './types';\r\n\r\nexport class TinyYolov2 extends NeuralNetwork<TinyYolov2NetParams> {\r\n\r\n  public static DEFAULT_FILTER_SIZES = [\r\n    3, 16, 32, 64, 128, 256, 512, 1024, 1024\r\n  ]\r\n\r\n  private _config: TinyYolov2Config\r\n\r\n  constructor(config: TinyYolov2Config) {\r\n    super('TinyYolov2')\r\n    validateConfig(config)\r\n    this._config = config\r\n  }\r\n\r\n  public get config(): TinyYolov2Config {\r\n    return this._config\r\n  }\r\n\r\n  public get withClassScores(): boolean {\r\n    return this.config.withClassScores || this.config.classes.length > 1\r\n  }\r\n\r\n  public get boxEncodingSize(): number {\r\n    return 5 + (this.withClassScores ? this.config.classes.length : 0)\r\n  }\r\n\r\n  public runTinyYolov2(x: tf.Tensor4D, params: DefaultTinyYolov2NetParams): tf.Tensor4D {\r\n\r\n    let out = convWithBatchNorm(x, params.conv0)\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\r\n    out = convWithBatchNorm(out, params.conv1)\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\r\n    out = convWithBatchNorm(out, params.conv2)\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\r\n    out = convWithBatchNorm(out, params.conv3)\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\r\n    out = convWithBatchNorm(out, params.conv4)\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\r\n    out = convWithBatchNorm(out, params.conv5)\r\n    out = tf.maxPool(out, [2, 2], [1, 1], 'same')\r\n    out = convWithBatchNorm(out, params.conv6)\r\n    out = convWithBatchNorm(out, params.conv7)\r\n\r\n    return convLayer(out, params.conv8, 'valid', false)\r\n  }\r\n\r\n  public runMobilenet(x: tf.Tensor4D, params: MobilenetParams): tf.Tensor4D {\r\n\r\n    let out = this.config.isFirstLayerConv2d\r\n      ? leaky(convLayer(x, params.conv0 as ConvParams, 'valid', false))\r\n      : depthwiseSeparableConv(x, params.conv0 as SeparableConvParams)\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\r\n    out = depthwiseSeparableConv(out, params.conv1)\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\r\n    out = depthwiseSeparableConv(out, params.conv2)\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\r\n    out = depthwiseSeparableConv(out, params.conv3)\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\r\n    out = depthwiseSeparableConv(out, params.conv4)\r\n    out = tf.maxPool(out, [2, 2], [2, 2], 'same')\r\n    out = depthwiseSeparableConv(out, params.conv5)\r\n    out = tf.maxPool(out, [2, 2], [1, 1], 'same')\r\n    out = params.conv6 ? depthwiseSeparableConv(out, params.conv6) : out\r\n    out = params.conv7 ? depthwiseSeparableConv(out, params.conv7) : out\r\n\r\n    return convLayer(out, params.conv8, 'valid', false)\r\n  }\r\n\r\n  public forwardInput(input: NetInput, inputSize: number): tf.Tensor4D {\r\n\r\n    const { params } = this\r\n\r\n    if (!params) {\r\n      throw new Error('TinyYolov2 - load model before inference')\r\n    }\r\n\r\n    return tf.tidy(() => {\r\n\r\n      let batchTensor = input.toBatchTensor(inputSize, false).toFloat()\r\n      batchTensor = this.config.meanRgb\r\n        ? normalize(batchTensor, this.config.meanRgb)\r\n        : batchTensor\r\n      batchTensor = batchTensor.div(tf.scalar(256)) as tf.Tensor4D\r\n\r\n      return this.config.withSeparableConvs\r\n        ? this.runMobilenet(batchTensor, params as MobilenetParams)\r\n        : this.runTinyYolov2(batchTensor, params as DefaultTinyYolov2NetParams)\r\n    })\r\n  }\r\n\r\n  public async forward(input: TNetInput, inputSize: number): Promise<tf.Tensor4D> {\r\n    return await this.forwardInput(await toNetInput(input), inputSize)\r\n  }\r\n\r\n  public async detect(input: TNetInput, forwardParams: ITinyYolov2Options = {}): Promise<ObjectDetection[]> {\r\n\r\n    const { inputSize, scoreThreshold } = new TinyYolov2Options(forwardParams)\r\n\r\n    const netInput = await toNetInput(input)\r\n    const out = await this.forwardInput(netInput, inputSize)\r\n    const out0 = tf.tidy(() => tf.unstack(out)[0].expandDims()) as tf.Tensor4D\r\n\r\n    const inputDimensions = {\r\n      width: netInput.getInputWidth(0),\r\n      height: netInput.getInputHeight(0)\r\n    }\r\n\r\n    const results = await this.extractBoxes(out0, netInput.getReshapedInputDimensions(0), scoreThreshold)\r\n    out.dispose()\r\n    out0.dispose()\r\n\r\n    const boxes = results.map(res => res.box)\r\n    const scores = results.map(res => res.score)\r\n    const classScores = results.map(res => res.classScore)\r\n    const classNames = results.map(res => this.config.classes[res.label])\r\n\r\n    const indices = nonMaxSuppression(\r\n      boxes.map(box => box.rescale(inputSize)),\r\n      scores,\r\n      this.config.iouThreshold,\r\n      true\r\n    )\r\n\r\n    const detections = indices.map(idx =>\r\n      new ObjectDetection(\r\n        scores[idx],\r\n        classScores[idx],\r\n        classNames[idx],\r\n        boxes[idx],\r\n        inputDimensions\r\n      )\r\n    )\r\n\r\n    return detections\r\n  }\r\n\r\n  protected getDefaultModelName(): string {\r\n    return ''\r\n  }\r\n\r\n  protected extractParamsFromWeigthMap(weightMap: tf.NamedTensorMap) {\r\n    return extractParamsFromWeigthMap(weightMap, this.config)\r\n  }\r\n\r\n  protected extractParams(weights: Float32Array) {\r\n    const filterSizes = this.config.filterSizes || TinyYolov2.DEFAULT_FILTER_SIZES\r\n\r\n    const numFilters = filterSizes ? filterSizes.length : undefined\r\n    if (numFilters !== 7 && numFilters !== 8 && numFilters !== 9) {\r\n      throw new Error(`TinyYolov2 - expected 7 | 8 | 9 convolutional filters, but found ${numFilters} filterSizes in config`)\r\n    }\r\n    return extractParams(weights, this.config, this.boxEncodingSize, filterSizes)\r\n  }\r\n\r\n  protected async extractBoxes(\r\n    outputTensor: tf.Tensor4D,\r\n    inputBlobDimensions: Dimensions,\r\n    scoreThreshold?: number\r\n  ) {\r\n\r\n    const { width, height } = inputBlobDimensions\r\n    const inputSize = Math.max(width, height)\r\n    const correctionFactorX = inputSize / width\r\n    const correctionFactorY = inputSize / height\r\n\r\n    const numCells = outputTensor.shape[1]\r\n    const numBoxes = this.config.anchors.length\r\n\r\n    const [boxesTensor, scoresTensor, classScoresTensor] = tf.tidy(() => {\r\n      const reshaped = outputTensor.reshape([numCells, numCells, numBoxes, this.boxEncodingSize])\r\n\r\n      const boxes = reshaped.slice([0, 0, 0, 0], [numCells, numCells, numBoxes, 4])\r\n      const scores = reshaped.slice([0, 0, 0, 4], [numCells, numCells, numBoxes, 1])\r\n      const classScores = this.withClassScores\r\n        ? tf.softmax(reshaped.slice([0, 0, 0, 5], [numCells, numCells, numBoxes, this.config.classes.length]), 3)\r\n        : tf.scalar(0)\r\n      return [boxes, scores, classScores]\r\n    })\r\n\r\n    const results = []\r\n\r\n    const scoresData = await scoresTensor.array()\r\n    const boxesData = await boxesTensor.array()\r\n    for (let row = 0; row < numCells; row ++) {\r\n      for (let col = 0; col < numCells; col ++) {\r\n        for (let anchor = 0; anchor < numBoxes; anchor ++) {\r\n\r\n          const score = sigmoid(scoresData[row][col][anchor][0]);\r\n          if (!scoreThreshold || score > scoreThreshold) {\r\n            const ctX = ((col + sigmoid(boxesData[row][col][anchor][0])) / numCells) * correctionFactorX\r\n            const ctY = ((row + sigmoid(boxesData[row][col][anchor][1])) / numCells) * correctionFactorY\r\n            const width = ((Math.exp(boxesData[row][col][anchor][2]) * this.config.anchors[anchor].x) / numCells) * correctionFactorX\r\n            const height = ((Math.exp(boxesData[row][col][anchor][3]) * this.config.anchors[anchor].y) / numCells) * correctionFactorY\r\n\r\n            const x = (ctX - (width / 2))\r\n            const y = (ctY - (height / 2))\r\n\r\n            const pos = { row, col, anchor }\r\n            const { classScore, label } = this.withClassScores\r\n              ? await this.extractPredictedClass(classScoresTensor as tf.Tensor4D, pos)\r\n              : { classScore: 1, label: 0 }\r\n\r\n            results.push({\r\n              box: new BoundingBox(x, y, x + width, y + height),\r\n              score: score,\r\n              classScore: score * classScore,\r\n              label,\r\n              ...pos\r\n            })\r\n          }\r\n        }\r\n      }\r\n    }\r\n\r\n    boxesTensor.dispose()\r\n    scoresTensor.dispose()\r\n    classScoresTensor.dispose()\r\n\r\n    return results\r\n  }\r\n\r\n  private async extractPredictedClass(classesTensor: tf.Tensor4D, pos: { row: number, col: number, anchor: number },) {\r\n    const { row, col, anchor } = pos\r\n    const classesData = await classesTensor.array()\r\n    return Array(this.config.classes.length).fill(0)\r\n      .map((_, i) => classesData[row][col][anchor][i])\r\n      .map((classScore, label) => ({\r\n        classScore,\r\n        label\r\n      }))\r\n      .reduce((max, curr) => max.classScore > curr.classScore ? max : curr)\r\n  }\r\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}